I"Y<h1 id="reversing-kavm---985-pts">[REVERSING] KAVM - 985 pts.</h1>

<p><br />
We’re given a file:
<img src="images/kavm_1.png# big" alt="file missing" />
<br /></p>

<p>And when we run it, it asks for magic password:
<img src="images/kavm_7.png# medium" alt="file missing" />
<br /></p>

<p>Checking it with gdb:
<img src="images/kavm_2.png# big-p" alt="file missing" />
The symbol table only contains plt entries.
Before digging in GDB, let’s analyze the binary with Ghidra.
<br /></p>

<p>After Ghidra was able to analyze the file, we’re able to find the main function:
<img src="images/kavm_3.png# medium-p" alt="file missing" />
<br /></p>

<p>But upon looking at GDB, we can see that there are is one more address called: 0x8048440 but we can ignore since what it does is only get the next instruction address and store it at ebx.
<img src="images/kavm_4.png# small" alt="file missing" />
<br /></p>

<p>However, what’s interesting is the result of ebx when added to 0x2ae6. Let’s run and set breakpoint at address 0x8048520:
<img src="images/kavm_5.png# medium" alt="file missing" />
As we can see from above image, the value of EBX = 0x804b000. Let’s check the byte contents.
<br /></p>

<p>Here is the byte contents from address0x804b000:
<img src="images/kavm_6.png# big" alt="file missing" /></p>

<p>Interesting! Some of the values lying around at different addresses looks like are printable bytes! It looks like for the VM this is where its <em>data segment</em> starts. Let’s check the values:</p>
<pre><code class="language-C">Addresses:
0x804b060 -&gt; "Welcome to SECURINETS CTF!\n"
0x804b0a0 -&gt; "Give me the magic:"
0x804b0e0 -&gt; "No...\n"
0x804b120 -&gt; "Just get out ; No place for you here!\n"
0x804b1a0 -&gt; "Good Job! You win!\n"
0x804b1e0 -&gt; "Sz}hnrt|ldmcyLbc {=nx::gWu6fo6#|"
</code></pre>
<p>The string at 0x804b1e0 is the definitely the most interesting one. In fact this is actually the encrypted flag. We just have to know how this is encrypted.
<br /></p>

<h2 id="how-does-the-vm-do-its-routine">How does the VM do its routine?</h2>
<p>Upon checking the Ghidra, we can see that it calls 0x8048568 and when we check the disassembly in GDB.0x8048568:</p>
<pre><code class="language-assembly">   0x8048568:	push   ebp				
   0x8048569:	mov    ebp,esp
   0x804856b:	push   ebx
   0x804856c:	sub    esp,0x24
   0x804856f:	call   0x8048440
   0x8048574:	add    ebx,0x2a8c
   0x804857a:	mov    eax,gs:0x14
   0x8048580:	mov    DWORD PTR [ebp-0xc],eax
   0x8048583:	xor    eax,eax
   0x8048585:	mov    DWORD PTR [ebp-0x28],0x0
   0x804858c:	cmp    DWORD PTR [ebp+0x8],0x14 #This checks the canary
   0x8048590:	ja     0x8048cb9	
   0x8048596:	mov    eax,DWORD PTR [ebp+0x8] #ebp + 0x8 is 0 at first loop
   0x8048599:	shl    eax,0x2
   0x804859c:	mov    eax,DWORD PTR [eax+ebx*1-0x226c] 
   0x80485a3:	add    eax,ebx
   0x80485a5:	jmp    eax

</code></pre>

:ET