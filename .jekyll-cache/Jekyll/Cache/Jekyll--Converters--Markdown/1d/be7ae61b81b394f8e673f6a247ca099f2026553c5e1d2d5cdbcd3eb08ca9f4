I"Y%<h1 id="reversing-kavm---985-pts">[REVERSING] KAVM - 985 pts.</h1>

<p><br />
We’re given a file:
<img src="images/kavm_1.png# big" alt="file missing" />
<br /></p>

<p>And when we run it, it asks for magic password:
<img src="images/kavm_7.png# medium" alt="file missing" />
<br /></p>

<p>Checking it with gdb:
<img src="images/kavm_2.png# big-p" alt="file missing" />
The symbol table only contains plt entries.
Before digging in GDB, let’s analyze the binary with Ghidra.
<br /></p>

<p>After Ghidra was able to analyze the file, we’re able to find the main function:
<img src="images/kavm_3.png# medium-p" alt="file missing" />
<br /></p>

<p>But upon looking at GDB, we can see that there are is one more address called: 0x8048440 but we can ignore since what it does is only get the next instruction address and store it at ebx.
<img src="images/kavm_4.png# small" alt="file missing" />
<br /></p>

<p>However, what’s interesting is the result of ebx when added to 0x2ae6. Let’s run and set breakpoint at address 0x8048520:
<img src="images/kavm_5.png# medium" alt="file missing" />
As we can see from above image, the value of EBX = 0x804b000. Let’s check the byte contents.
<br /></p>

<p>Here is the byte contents from address0x804b000:
<img src="images/kavm_6.png# big" alt="file missing" /></p>

<p>Interesting! Some of the values lying around at different addresses looks like are printable bytes! It looks like for the VM this is where its <em>data segment</em> starts. Let’s check the values:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">Addresses:</span>
<span class="mh">0x804b060</span> <span class="o">-&gt;</span> <span class="s">"Welcome to SECURINETS CTF!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b0a0</span> <span class="o">-&gt;</span> <span class="s">"Give me the magic:"</span>
<span class="mh">0x804b0e0</span> <span class="o">-&gt;</span> <span class="s">"No...</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b120</span> <span class="o">-&gt;</span> <span class="s">"Just get out ; No place for you here!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b1a0</span> <span class="o">-&gt;</span> <span class="s">"Good Job! You win!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b1e0</span> <span class="o">-&gt;</span> <span class="s">"Sz}hnrt|ldmcyLbc {=nx::gWu6fo6#|"</span>
</code></pre></div></div>
<p>The string at 0x804b1e0 is the definitely the most interesting one. In fact this is actually the encrypted flag. We just have to know how this is encrypted.
<br /></p>

<h2 id="how-does-the-vm-do-its-routine">How does the VM do its routine?</h2>
<p>Upon checking the Ghidra, we can see that it calls 0x8048568 and when we check the disassembly in GDB.0x8048568:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mh">0x8048568</span><span class="o">:</span>	<span class="n">push</span>   <span class="n">ebp</span>				
   <span class="mh">0x8048569</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
   <span class="mh">0x804856b</span><span class="o">:</span>	<span class="n">push</span>   <span class="n">ebx</span>
   <span class="mh">0x804856c</span><span class="o">:</span>	<span class="n">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x24</span>
   <span class="mh">0x804856f</span><span class="o">:</span>	<span class="n">call</span>   <span class="mh">0x8048440</span>
   <span class="mh">0x8048574</span><span class="o">:</span>	<span class="n">add</span>    <span class="n">ebx</span><span class="p">,</span><span class="mh">0x2a8c</span>
   <span class="mh">0x804857a</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">gs</span><span class="o">:</span><span class="mh">0x14</span>
   <span class="mh">0x8048580</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span><span class="p">],</span><span class="n">eax</span>
   <span class="mh">0x8048583</span><span class="o">:</span>	<span class="n">xor</span>    <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>
   <span class="mh">0x8048585</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x28</span><span class="p">],</span><span class="mh">0x0</span>
   <span class="mh">0x804858c</span><span class="o">:</span>	<span class="n">cmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">],</span><span class="mh">0x14</span> <span class="err">#</span><span class="n">This</span> <span class="n">checks</span> <span class="n">the</span> <span class="n">canary</span>
   <span class="mh">0x8048590</span><span class="o">:</span>	<span class="n">ja</span>     <span class="mh">0x8048cb9</span>	
   <span class="mh">0x8048596</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">ebp</span><span class="o">+</span><span class="mh">0x8</span><span class="p">]</span> <span class="err">#</span><span class="n">ebp</span> <span class="o">+</span> <span class="mh">0x8</span> <span class="n">is</span> <span class="mi">0</span> <span class="n">at</span> <span class="n">first</span> <span class="n">loop</span>
   <span class="mh">0x8048599</span><span class="o">:</span>	<span class="n">shl</span>    <span class="n">eax</span><span class="p">,</span><span class="mh">0x2</span>
   <span class="mh">0x804859c</span><span class="o">:</span>	<span class="n">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">eax</span><span class="o">+</span><span class="n">ebx</span><span class="o">*</span><span class="mi">1</span><span class="o">-</span><span class="mh">0x226c</span><span class="p">]</span> 
   <span class="mh">0x80485a3</span><span class="o">:</span>	<span class="n">add</span>    <span class="n">eax</span><span class="p">,</span><span class="n">ebx</span>
   <span class="mh">0x80485a5</span><span class="o">:</span>	<span class="n">jmp</span>    <span class="n">eax</span>
</code></pre></div></div>
<p>Taking a look to the assembly above, what interests us is from address 0x8048596 - 0x80485a5 since this is how <strong>addresses to different functions is calculated</strong>. The most critical one for us is 0x80485a5 since this jumps to the subroutine the program is going to do. We can ignore everything else in it
<br /></p>

<p>Let’s set a breakpoint to this address. When we run it, it will point to different address and it will do what it needs to be done (e.g. getting input, printing, encrypting etc.). However, we’re only concerned to addresses that <strong>(a) gets input</strong> and <strong>(b) encrypts our input</strong> because we will only have to check the transformation of our input once we get to the encryption function.</p>

<h2 id="getting-user-input-address">Getting user input address</h2>

<p>We will know the address that gets user input at registerEAX when it stops at our breakpoint and when we hit “continue” the program asks for a user input.
<img src="images/kavm_8.png# big-p" alt="file missing" />
As we can see, the user input get function is at address 0x8048851. We’ll insert the following input above lol.
<br /></p>

<p>Let’s check where does it store our user input. By following <strong>any</strong> jump instruction from that address, we will arrive at address 0x80488c9:
<img src="images/kavm_9.png# medium-p" alt="file missing" />
Let’s set breakpoint to 0x80488ef. Let’s rerun the program again and check the stack since it will contain the destination address. Here is the stack value when it our breakpoints.:
<img src="images/kavm_10.png# big" alt="file missing" />
Since scanf is used for getting the user input, the second value in the stack is actually the address where our input is stored! Address of our input is : 0x804b240. We can confirm this by stepping another instruction (Remark: Scanf doesn’t include strings after the first space!)
<img src="images/kavm_11.png" alt="file missing" />. 
<br /></p>
<h3 id="minor-problem">Minor problem</h3>
<p>However, our input seems not to be encrypted. We can know this be setting our breakpoint again to 0x80485a5 and by checking our string input <code class="highlighter-rouge">x/s 0x804b240</code> every time it hits our breakpoint. “No…” is printed but there are no changes to our input. When we rerun our program again with the same breakpoint and still checking the our input, at some point the program jumps to address 0x804894e which has <code class="highlighter-rouge">strlen()</code> in it.
<img src="images/kavm_12.png" alt="file missing" /></p>

<h2 id="the-encryption-function">The Encryption function</h2>

:ET