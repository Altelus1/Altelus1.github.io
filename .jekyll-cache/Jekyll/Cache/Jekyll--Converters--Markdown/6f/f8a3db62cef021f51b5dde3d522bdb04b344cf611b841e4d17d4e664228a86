I"¬<h1 id="reversing-discount-vmprotect---465-pts">[REVERSING] Discount VMProtect - 465 Pts.</h1>
<p><br /></p>

<h1 id="challenge-description">Challenge Description:</h1>

<p><img src="images/discountvmprotect_1.png" alt="lol it didn't load" /></p>

<p><br />
Then the challenge gives us this file:
<img src="images/discountvmprotect_2.png" alt="lol it didn't load" /></p>

<p><br />
Let‚Äôs see what the ELF file does.
<img src="images/discountvmprotect_3.png" alt="lol it didn't load" /></p>

<p>It basically asks for a password then checks if it matches to the password embedded inside the executable, which is also probably the flag.</p>

<p><br />
Let‚Äôs run gdb on it and do static analysis. Let‚Äôs check for functions and how much symbols is left since the <code class="highlighter-rouge">file</code> command says it is stripped.</p>

<p><img src="images/discountvmprotect_4.png" alt="lol it didn't load" />
Hmmm‚Ä¶ There is no main and only plt entries remained. Let‚Äôs find the entry point and the main then.
<br />
The entry point is at <code class="highlighter-rouge">0x400770</code>.
<img src="images/discountvmprotect_5.png" alt="lol it didn't load" /></p>

<p><br />
Then our main address is 0x400c88.
<img src="images/discountvmprotect_6.png" alt="lol it didn't load" />
<br /></p>

<p>This is the whole main assembly code
<img src="images/discountvmprotect_7.png" alt="lol it didn't load" /></p>

<p>Summary of main:</p>
<ul>
  <li>The program asks for user input and stores it to 0x6026a0, calls 0x400857, then if the first byte from 0x6025a0 is 1, then we got the password.</li>
</ul>

<p><br />
Let‚Äôs check Ghidra if we got the same analysis to it.
<img src="images/discountvmprotect_9.png" alt="lol it didn't load" />
We got the same analysis. Great! We noticed also that the 0x400857 is called two times. Let‚Äôs see what 0x400857 does.
<br />
In Ghidra:
<img src="images/discountvmprotect_10.png" alt="lol it didn't load" />
Hmmm‚Ä¶ weird, it only returns. Let‚Äôs check gdb then.
<br /></p>

<p>In GDB:
<img src="images/discountvmprotect_8.png" alt="lol it didn't load" />
It looks like this function offers a lot more than just returning. It pushes 0x2361ca to the stack then it XORs it with 0x636465. The value after XORing is 0x40087f then returning. Since 0x40087f is the top of the stack, the code actually jumps to that address instead of going back to main. Let‚Äôs check Ghidra what‚Äôs inside 0x40087f.
<img src="images/discountvmprotect_11.png" alt="lol it didn't load" />
<img src="images/discountvmprotect_12.png" alt="lol it didn't load" />
<img src="images/discountvmprotect_13.png" alt="lol it didn't load" />
Woah! I think we just stumbled a treasure! However, there‚Äôs a lot of code and it looks scary. Second, what‚Äôs the deal with this loop? After a lot of headbanging and searching, I found this article about VM protectd binaries. I suggest to give it a read. <a href="https://resources.infosecinstitute.com/reverse-engineering-virtual-machine-protected-binaries/#gref">VM Protected Binaries Article</a>. 
<br />
TL;DR: A Binary that‚Äôs VM protected has its own set of ‚Äúinstructions‚Äù, has a function that acts like a processor then reads the instructions, and has its own memory (stack, heap, etc. depending on the design). The 0x40087f is actually the function that executes those instructions. We can also see the values in the switch cases. These are the opcodes of the instructions.
<br />
Now that we know what what the big loop is, we have to answer the following questions:
a) Where does the binary get the instructions?
b) What does each opcode do?
c) This is the main part of the program therefore the flag is connected to it somewhere.
<br />
Let‚Äôs answer (a).
Let‚Äôs back at 0x400857 before jumping to 0x</p>

:ET