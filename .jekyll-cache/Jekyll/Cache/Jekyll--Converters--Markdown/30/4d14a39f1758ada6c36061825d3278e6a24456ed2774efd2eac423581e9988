I"Ã<h1 id="reversing-discount-vmprotect---465-pts">[REVERSING] Discount VMProtect - 465 Pts.</h1>
<p><br /></p>

<h1 id="challenge-description">Challenge Description:</h1>

<p><img src="images/discountvmprotect_1.png" alt="lol it didn't load" /></p>

<p><br />
Then the challenge gives us this file:
<img src="images/discountvmprotect_2.png" alt="lol it didn't load" /></p>

<p><br />
Let‚Äôs see what the ELF file does.
<img src="images/discountvmprotect_3.png" alt="lol it didn't load" /></p>

<p>It basically asks for a password then checks if it matches to the password embedded inside the executable, which is also probably the flag.</p>

<p><br />
Let‚Äôs run gdb on it and do static analysis. Let‚Äôs check for functions and how much symbols is left since the <code class="highlighter-rouge">file</code> command says it is stripped.</p>

<p><img src="images/discountvmprotect_4.png" alt="lol it didn't load" />
Hmmm‚Ä¶ There is no main and only plt entries remained. Let‚Äôs find the entry point and the main then.
<br />
The entry point is at <code class="highlighter-rouge">0x400770</code>.
<img src="images/discountvmprotect_5.png" alt="lol it didn't load" /></p>

<p><br />
Then our main address is 0x400c88.
<img src="images/discountvmprotect_6.png" alt="lol it didn't load" />
<br /></p>

<p>This is the whole main assembly code
<img src="images/discountvmprotect_7.png" alt="lol it didn't load" /></p>

<p>Summary of main:</p>
<ul>
  <li>The program asks for user input and stores it to 0x6026a0, calls 0x400857, then if the first byte from 0x6025a0 is 1, then we got the password.</li>
</ul>

<p><br />
Let‚Äôs check Ghidra if we got the same analysis to it.
<img src="images/discountvmprotect_9.png" alt="lol it didn't load" />
We got the same analysis. Great! We noticed also that the 0x400857 is called two times. Let‚Äôs see what 0x400857 does.
<br />
In Ghidra:
<img src="images/discountvmprotect_10.png" alt="lol it didn't load" />
Hmmm‚Ä¶ weird, it only returns. Let‚Äôs check gdb then.
<br /></p>

<p>In GDB:
<img src="images/discountvmprotect_8.png" alt="lol it didn't load" />
It looks like this function offers a lot more than just returning. It pushes 0x2361ca to the stack then it XORs it with 0x636465. The value after XORing is 0x40087f then returning. Since 0x40087f is the top of the stack, the code actually jumps to that address instead of going back to main. Let‚Äôs check Ghidra what‚Äôs inside 0x40087f.
<img src="images/discountvmprotect_11.png" alt="lol it didn't load" />
<img src="images/discountvmprotect_12.png" alt="lol it didn't load" />
<img src="images/discountvmprotect_13.png" alt="lol it didn't load" />
Woah! I think we just stumbled a treasure! However, there‚Äôs a lot of code and it looks scary. Second, what‚Äôs the deal with this loop? After a lot of headbanging and searching, I found this article about VM protectd binaries. I suggest to give it a read. <a href="https://resources.infosecinstitute.com/reverse-engineering-virtual-machine-protected-binaries/#gref">VM Protected Binaries Article</a>. 
<br />
TL;DR: A Binary that‚Äôs VM protected has its own set of ‚Äúinstructions‚Äù, has a function that acts like a processor then reads the instructions, and has its own memory (stack, heap, etc. depending on the design). The 0x40087f is actually the function that executes those instructions. We can also see the values in the switch cases. These are the opcodes of the instructions.
<br />
Now that we know what the big loop is, we have to answer the following questions:
a) Where does the binary get the instructions?
b) What does each opcode do?
c) This is the main part of the program therefore the flag is connected to it somewhere and somehow. So where is it?
<br />
Let‚Äôs answer (a).
Let‚Äôs go back at 0x400857 before jumping to 0x40087f
<img src="images/discountvmprotect_8.png" alt="lol it didn't load" /></p>

<p>Before the XOR operation, we can see that rdi value is being stored to rbp-0x28:</p>
<ul>
  <li>rbp-0x28 = rdi</li>
  <li>rbp-0x8 = 0x0</li>
  <li>rbp-0x4 = 0x0</li>
</ul>

<p>Also, a very important note, those values above appeared in every operation for every opcode inside the big loop.
But what is the value of rdi? Going back to main.
<img src="images/discountvmprotect_14.png" alt="lol it didn't load" /></p>

<p>Addresses 0x602320 and 0x6020e0 are passed as arguments to 0x400857 function.
What‚Äôs inside in this address?</p>

<p>Contents: of 0x602320
<img src="images/discountvmprotect_15.png" alt="lol it didn't load" /></p>

<p>Contents: of 0x6020e0
<img src="images/discountvmprotect_16.png" alt="lol it didn't load" /></p>

<p>We can see many of the bytes are starting in 3 (i.e. 0x32, 0x36, 0x33 etc.)
Could this be the instructions? It most likely is but to confirm things let‚Äôs go Ghidra and check the decompiled code at 0x40087f.</p>

<p><img src="images/discountvmprotect_17.png" alt="lol it didn't load" /></p>

<p>Basically, what it says: 
[rbp-0x17] = [rbp-0x28][rbp-0x4]; #access the byte from [rbp-0x28] at offset [rbp-0x4]
[rbp-0x4] += 1</p>

<p>Then the value at [rbp-0x17] is being used to check against the cases for opcodes thus it the addresses 0x602320 and 0x6020e0. We should also noticed that offset lies in [rbp-0x4] therefore this is the instruction pointer.</p>

<p>Takeaways:
[rbp-0x28] is the base address. The value is set in the 0x400857 through rdi which came from the main function
[rbp-0x4] is the pointer.
[rbp-0x8] ??? -&gt; we don‚Äôt know this yet.</p>

<p>Let‚Äôs answer (b):
Since there are a lot of opcodes, this is the list of each opcode.</p>

:ET