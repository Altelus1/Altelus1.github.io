I"Ò<h1 id="reversing-kavm---985-pts">[REVERSING] KAVM - 985 pts.</h1>

<p><br />
We‚Äôre given a file:
<img src="images/kavm_1.png# big" alt="file missing" />
<br /></p>

<p>And when we run it, it asks for magic password:
<img src="images/kavm_7.png# medium" alt="file missing" />
<br /></p>

<p>Checking it with gdb:
<img src="images/kavm_2.png# big-p" alt="file missing" />
The symbol table only contains plt entries.
Before digging in GDB, let‚Äôs analyze the binary with Ghidra.
<br /></p>

<p>After Ghidra was able to analyze the file, we‚Äôre able to find the main function:
<img src="images/kavm_3.png# medium-p" alt="file missing" />
<br /></p>

<p>But upon looking at GDB, we can see that there are is one more address called: 0x8048440 but we can ignore since what it does is only get the next instruction address and store it at ebx.
<img src="images/kavm_4.png# small" alt="file missing" />
<br /></p>

<p>However, what‚Äôs interesting is the result of ebx when added to 0x2ae6. Let‚Äôs run and set breakpoint at address 0x8048520:
<img src="images/kavm_5.png# medium" alt="file missing" />
As we can see from above image, the value of EBX = 0x804b000. Let‚Äôs check the byte contents.
<br /></p>

<p>Here is the byte contents from address0x804b000:
<img src="images/kavm_6.png# big" alt="file missing" /></p>

<p>Interesting! Some of the values lying around at different addresses looks like are printable bytes! It looks like for the VM this is where its <em>data segment</em> starts. Let‚Äôs check the values:</p>
<pre><code class="language-C">Addresses:
0x804b060 -&gt; "Welcome to SECURINETS CTF!\n"
0x804b0a0 -&gt; "Give me the magic:"
0x804b0e0 -&gt; "No...\n"
0x804b120 -&gt; "Just get out ; No place for you here!\n"
0x804b1a0 -&gt; "Good Job! You win!\n"
0x804b1e0 -&gt; "Sz}hnrt|ldmcyLbc {=nx::gWu6fo6#|"
</code></pre>
<p>The string at 0x804b1e0 is the definitely the most interesting one. In fact this is actually the encrypted flag. We just have to know how this is encrypted.
<br /></p>

<h2 id="how-does-the-vm-do-its-routine">How does the VM do its routine?</h2>
<p>Upon checking the Ghidra, we can see that it calls 0x8048568 and when we check the disassembly in GDB.0x8048568:</p>
<pre><code class="language-assembly">   0x8048568:	push   ebp				
   0x8048569:	mov    ebp,esp
   0x804856b:	push   ebx
   0x804856c:	sub    esp,0x24
   0x804856f:	call   0x8048440
   0x8048574:	add    ebx,0x2a8c
   0x804857a:	mov    eax,gs:0x14
   0x8048580:	mov    DWORD PTR [ebp-0xc],eax
   0x8048583:	xor    eax,eax
   0x8048585:	mov    DWORD PTR [ebp-0x28],0x0
   0x804858c:	cmp    DWORD PTR [ebp+0x8],0x14 #This checks the canary
   0x8048590:	ja     0x8048cb9	
   0x8048596:	mov    eax,DWORD PTR [ebp+0x8] #ebp + 0x8 is 0 at first loop
   0x8048599:	shl    eax,0x2
   0x804859c:	mov    eax,DWORD PTR [eax+ebx*1-0x226c] 
   0x80485a3:	add    eax,ebx
   0x80485a5:	jmp    eax
</code></pre>
<p>Taking a look to the assembly above, what interests us is from address 0x8048596 - 0x80485a5 since this is how <strong>addresses to different functions is calculated</strong>. The most critical one for us is 0x80485a5 since this jumps to the subroutine the program is going to do. We can ignore everything else in it
<br /></p>

<p>Let‚Äôs set a breakpoint to this address. When we run it, it will point to different address and it will do what it needs to be done (e.g. getting input, printing, encrypting etc.). However, we‚Äôre only concerned to addresses that <strong>(a) gets input</strong> and <strong>(b) encrypts our input</strong>. We will know the address that gets user input at register EAX when it stops at our breakpoint and when we hit ‚Äúcontinue‚Äù the program asks for a user input.
<img src="images/kavm_8.png# big-p" alt="file missing" />
As we can see, the user input get function is at address 0x8048851. We‚Äôll insert the following input above lol.
<br /></p>

<p>Let‚Äôs check where does it store our user input. By following <strong>any</strong> jump instruction from that address, we will arrive at address 0x80488c9:
<img src="images/kavm_9.png# medium-p" alt="file missing" />
Let‚Äôs set breakpoint to 0x80488ee. Let‚Äôs rerun the program again and check the EAX and the stack. Here is our register values:
<img src="images/kavm_10.png" alt="file missing" />
<br />
And here is our Stack content</p>

:ET