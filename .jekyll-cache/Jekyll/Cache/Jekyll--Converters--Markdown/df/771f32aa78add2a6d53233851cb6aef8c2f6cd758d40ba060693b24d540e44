I"<h1 id="reversing-kavm---985-pts">[REVERSING] KAVM - 985 pts.</h1>

<p><br />
We’re given a file:
<img src="images/kavm_1.png# big" alt="file missing" />
<br /></p>

<p>And when we run it, it asks for magic password:
<img src="images/kavm_7.png# medium" alt="file missing" />
<br /></p>

<p>Checking it with gdb:
<img src="images/kavm_2.png# big-p" alt="file missing" />
The symbol table only contains plt entries.
Before digging in GDB, let’s analyze the binary with Ghidra.
<br /></p>

<p>After Ghidra was able to analyze the file, we’re able to find the main function:
<img src="images/kavm_3.png# medium-p" alt="file missing" />
<br /></p>

<p>But upon looking at GDB, we can see that there are is one more address called: 0x8048440 but we can ignore since what it does is only get the next instruction address and store it at ebx.
<img src="images/kavm_4.png# small" alt="file missing" />
<br /></p>

<p>However, what’s interesting is the result of ebx when added to 0x2ae6. Let’s run and set breakpoint at address 0x8048520:
<img src="images/kavm_5.png# medium" alt="file missing" />
As we can see from above image, the value of EBX = 0x804b000. Let’s check the byte contents.
<br /></p>

<p>Here is the byte contents from address0x804b000:
<img src="images/kavm_6.png# big" alt="file missing" /></p>

<p>Interesting! Some of the values lying around at different addresses looks like are printable bytes! It looks like for the VM this is where its <em>data segment</em> starts. Let’s check the values:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">Addresses:</span>
<span class="mh">0x804b060</span> <span class="o">-&gt;</span> <span class="s">"Welcome to SECURINETS CTF!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b0a0</span> <span class="o">-&gt;</span> <span class="s">"Give me the magic:"</span>
<span class="mh">0x804b0e0</span> <span class="o">-&gt;</span> <span class="s">"No...</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b120</span> <span class="o">-&gt;</span> <span class="s">"Just get out ; No place for you here!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b1a0</span> <span class="o">-&gt;</span> <span class="s">"Good Job! You win!</span><span class="se">\n</span><span class="s">"</span>
<span class="mh">0x804b1e0</span> <span class="o">-&gt;</span> <span class="s">"Sz}hnrt|ldmcyLbc {=nx::gWu6fo6#|"</span>
</code></pre></div></div>
<p>The string at 0x804b1e0 is the definitely the most interesting one. In fact this is actually the encrypted flag. We just have to know how this is encrypted.
<br /></p>

<h2 id="how-does-the-vm-do-its-routine">How does the VM do its routine?</h2>
<p>Upon checking the Ghidra, we can see that it calls 0x8048568 and when we check the disassembly in GDB.0x8048568:</p>
<pre><code class="language-x86">   0x8048568:	push   ebp				
   0x8048569:	mov    ebp,esp
   0x804856b:	push   ebx
   0x804856c:	sub    esp,0x24
   0x804856f:	call   0x8048440
   0x8048574:	add    ebx,0x2a8c
   0x804857a:	mov    eax,gs:0x14
   0x8048580:	mov    DWORD PTR [ebp-0xc],eax
   0x8048583:	xor    eax,eax
   0x8048585:	mov    DWORD PTR [ebp-0x28],0x0
   0x804858c:	cmp    DWORD PTR [ebp+0x8],0x14 #This checks the canary
   0x8048590:	ja     0x8048cb9	
   0x8048596:	mov    eax,DWORD PTR [ebp+0x8] #ebp + 0x8 is 0 at first loop
   0x8048599:	shl    eax,0x2
   0x804859c:	mov    eax,DWORD PTR [eax+ebx*1-0x226c] 
   0x80485a3:	add    eax,ebx
   0x80485a5:	jmp    eax
</code></pre>
<p>Taking a look to the assembly above, what interests us is from address 0x8048596 - 0x80485a5 since this is how <strong>addresses to different functions is calculated</strong>. The most critical one for us is 0x80485a5 since this jumps to the subroutine the program is going to do. We can ignore everything else in it
<br /></p>

<p>Let’s set a breakpoint to this address. When we run it, it will point to different address and it will do what it needs to be done (e.g. getting input, printing, encrypting etc.). However, we’re only concerned to addresses that <strong>(a) gets input</strong> and <strong>(b) encrypts our input</strong>. We will know the address that gets user input at register EAX when it stops at our breakpoint and when we hit “continue” the program asks for a user input.
<img src="images/kavm_8.png# big-p" alt="file missing" />
As we can see, the user input get function is at address 0x8048851. We’ll insert the following input above lol.
<br /></p>

<p>Let’s check where does it store our user input. By following <strong>any</strong> jump instruction from that address, we will arrive at address 0x80488c9:
<img src="images/kavm_9.png# medium-p" alt="file missing" />
Let’s set breakpoint to 0x80488ef. Let’s rerun the program again and check the stack since it will contain the destination address. Here is the stack value when it our breakpoints.:
<img src="images/kavm_10.png# big" alt="file missing" />
Since scanf is used for getting the user input, the second value in the stack is actually the address where our input is stored! Address of our input is : 0x804b240. We can confirm this by stepping another instruction (Remark: Scanf doesn’t include strings after the first space!)
<br />
And here is our Stack content</p>

:ET